# 분기다루기

## 1. 값식문

> 문법이 중요한 이유

: 프로그래밍도 하나의 언어이기 때문에
: 컴퓨터를 이해 시켜주어야 하기 때문에, 이해시키지 못한다면 문법(syntax)에러 발생 -> 큰 서비스 오류로 이어짐

> Case 1

```js
// JSX 문법
ReactDOM.render(<div id="msg">Hello World!</div>, mountNode);

// is transformed to this JS by Babel:
ReactDOM.render(
  React.createElement("div", { id: "msg" }, "Hello World!"),
  mountNode
);
```

> case 2

: 객체의 값으로 문(if,while)은 들어갈 수 없다.
: 삼항연산자와 같은 식은 값을 할당하기 때문에 객체의 값으로 사용가능하다.

```js
//JSX
<div id={if (condition) {'msg'}}>Hello World</div>

//It is transeformed to this JS by Babel
React.createElement("div", {id: if(condition){'msg'}} , "Hello World");
// 동작하지 않음 : 객체의 값으로 if조건문이 들어갔기 때문에

<div id ={condition ? 'msg' : null}> Hello World </div>
// 정상 동작: 객체의 값으로 삼항연산자 식에 의해 값이 할당되기 때문
```

> case 3

: (꼼수)조건문이 값을 바로 리턴하도록 한다면 사용가능하다. (by IIFE,즉시실행함수)

> case 4

: 조건문을 통해 값을 만드는 것보다, 고차함수를 이용하여 값과 식으로만 코드를 개선할 수 있다.

> case 5

### 요약

함수의 인자들로 조건문,for문 등을 받을 수 있을까에 대한 고민에서 시작

React의 JSX는 Babel에 의해 transeformed 되는데, 이 때 JSX의 요소들은 함수의 인자들로 취급된다.<br />
함수의 인자들은 `값과 식`으로만 이루어져야 하므로 if문,for문 등은 문법오류를 발생시킨다.

즉시실행함수로 감싼다면 조건문들도 사용가능할 수 있지만, 고차함수등을 이용하여 값과 식을 사용하는 것을 지향한다.

## 2. 삼항 연산자 다루기

> 삼항연산자의 일관성

: 삼항 연산자를 이용한 나만의 방법이 있는가? 숏코딩에 주로 사용하는가?
: 삼항연산자를 사용함에 있어서 일관성을 가지는 것이 중요하다.

> 삼항연산자 조건

: 삼항연산자는 3개의 `피연산자`를 가진다.
: `조건` ? `참`[식] : `거짓` [식]
: 참과 거짓 연산자는 `식`임에 주의 (if문, for문 불가)

> 01.삼항연산자 BadCase

: if-else 문을 사용하는 것이 훨씬 더 직관적으로 이해하기 좋다
: if-else 문 보다는 switch문을 이용하는 게 더 적합하다.
: edge케이스를 else로 처리하는 것보다 default로 처리하는 것이 현업에서 더 자주 사용

```js
function example() {
  return condition1
    ? value1
    : condition2
    ? value2
    : condition3
    ? value3
    : value4;
}

function example() {
  if (condition1) {
    return value1;
  } else if (condition2) {
    return value2;
  } else if (condition3) {
    return value3;
  } else {
    return value4;
  }
}

function example() {
  const condition = condition1 || condition2 || condition3 || condition4;
  let value = "";

  switch (condition) {
    case conditon1:
      value = value1;
      break;
    case conditon2:
      value = value2;
      break;
    case conditon3:
      value = value3;
      break;
    default:
      value = value4;
  }
  return value;
}
```

> 02.삼항연산자 BAD Case

: 삼항연산자가 중첩되어 있기 때문에, 직관적으로 파악하기 어렵다.
: 따라서 사람중심적으로 생각하여 이해가 쉽도록 한다.
: `괄호`를 통래 우선순위를 직관적으로 파악할 수 있도록 한다.
```js
//BAD CASE
const example = condition1 
? a === 0 
  ? "zero" 
  : "positive"
: "negative";

//BETTER CASE
const exampler = condition1
? ((a === 0) ? "zero" : "positive")
: "negative";
```

> 03.삼함연산자 GODD CASE
 : Nullable 한 상황에서 예외처리를 위해 삼항연산자를 사용할 수 있다.

 ```js
 const welcomeMessage = (isLogin) => {
   const name = isLogin ? getName() : "이름없음";

   return `안녕하세요 ${name}`;
 }

 //if문을 이용한 BAD CASE
  const welcomeMessage = (isLogin) => {
  if (isLogin) {
    return `안녕하세요 ${getName()}`;
  }
   return `안녕하세요 이름없음`;
 };
 ```

 > 04.삼항연산자 BAD CASE

 : alert는 인자에 상관없이 'undefined'를 반환하기 때문에, 사실상 isAdult에 따라서 같은 값을 반환하고 있다.
 : 따라서 삼항연산자의 본질보다는 `숏코딩`에 가까운 CASE이다.

 ```js
 function alertMessage(isAdult){
   isAdult 
    ? alert('입장이 가능합니다.')
    : alert('입장이 불가능합니다.');
 }

//BETTER CASE
 function alertMessage(isAdult){
   if(isAdult){
     alert('입장이 가능합니다.')
   } else {
     alert('입장이 불가능합니다.');
   }
 }
 ```

> 05.Poco의 삼항연산자 사용 CASE
 
 : 1. 삼항연산자를 사용해서 무언가의 값을 만들고 변수로 담아낼 때
  `const name = isLogin ? getName() : "이름없음"; `
 : 2. 함수가 내뱉는 값이 간단할 때
  `return isAdult ? '입장이 가능합니다' : '입장이 불가합니다'; `

### 요약
삼항연산자는 3개의 피연산자를 가지고, 피연산자는 `식`임에 주의해야한다.
삼항연산자는 주로 조건에 따라 다른 값을 뱉어낼 때 사용된다.
삼항연산자를 중첩해서 사용한다면 사용자가 직관적이해가 어려울 수 있으므로 if-else문, switch문을 고려하고, 단순 숏코딩을 위해서 사용하는 것이 아닌지 체크한다.

삼항연산자 사용은 자신만의 기준을 가지고 일관성 있게 사용하는 것이 바람직하다.
## 3. Truthy & Falsy
js동적인 타입이기 때문에, 의도하지 않은 형변환이 자주 발생한다.

> Truthy한 값
- true, {} , [] , 42, "0", "false", new Date(), -42, 3.14, 12n, Infinity, -Infinity

> Falsy한 값
- false, null, undefined, 0 ,NaN, '',  -0, 0n

: 엄격한 조건보다는 null || undefined를 동시에 체크해야할 때 !Falsy를 통해 주로 사용한다.
## 4. 단축평가 (short-circuit evaluatuion)

: 단축평가란 논리연산자, 삼항연산자를 통해 어디까지 값이 계산되는지를 파악하고, 최대한 계산량을 줄이는 것.
: && 연산자는 하나라도 Falsy가 나오면 계산을 멈춤
: || 연산자는 하나라도 Truthy가 나오면 계산을 멈춤

```js
true && true && '도달 O' 
true && false && '도달 X'

false || false || '도달 O'
true || false || '도달 X' // false 리턴
true || true || '도달 X' 
```

> 단축평가를 통해 if문을 줄여서 사용할 수가 있다.

: or연산자는 default값이 정해져있을 때 사용하기 편리하다.
: `return 할당되는값 || default값`

> 01.or연산자 CASE
```js
// BAD Case - if문
function fetchDate(){
  if(state.data){
    return state.data;
  } else {
    return 'Fetching...';
  }
}
// BAD Case - 삼항연산자
function fetchDate(){
  return state.data ? state.data : 'Fething...'
}

// GOOD Case - or단축평가
function fetchDate(){
  return state.data || 'Fetching...'
}
```

> 02.or연산자 CASE
```js
// BAD CASE
function favoriteDog(someDog){
  let favoriteDog;
  if(someDog){
    favoriteDog = someDog;
  } else {
    favoriteDog = '냐옹';
  }

  return favoriteDog + '입니다';
}

// GOOD CASE
function favoriteDog(someDog){
  return (someDog || '냐옹') + '입니다'
}
```

>03.
```js
// CASE 
const getActiveUserName = (user, isLogin) => {
  if(isLogin){
    if(user){
      if(user.name){
        return user.name
      } else {
        return '이름없음'
      }
    }
  }
}

// GOOD CASE 
// &&연산자로 한 depth 처리
const getActiveUserName = (user, isLogin) => {
  if(isLogin && user){
    if(user.name){
      return user.name
    } else {
      return '이름없음'
    }
  }
}

// || 연산자로 default값 처리
const getActiveUserName = (user, isLogin) => {
  if(isLogin && user){
      return user.name || '이름없음'
    }
  }
}
```

## 5. else if 피하기

## 6. else 피하기

## 7. early Return

## 8. 부정 조건문 지양하기

## 9. Default Case 고려하기

## 10. 명시적인 연산자 사용 지향하기

## 11. Nullish coalscing operator

## 12 드모르간의 법칙


- 프리티어: option + shift + f